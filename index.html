<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Big Little Lies, Big Little Types</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/big-little-types.css">

    <!-- Theme used for syntax highlighted code -->
    <!--    <link rel="stylesheet" href="plugin/highlight/monokai.css">-->
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section>
            <section>
                <div class="r-stack">
                    <h1 class="fragment fade-out" data-fragment-index="0">
                        Big Little Lies,<br>
                        Big Little Types
                    </h1>
                    <h2 class="fix-heading-alignment fragment" data-fragment-index="0">
                        Making React More Type Safe With Type-Tagging in Scala.js
                    </h2>
                </div>
                <div class="r-stack">
                    <img class="hero" data-src="assets/big-little-lies.jpg">
                    <img class="logo fragment" data-fragment-index="0" data-src="assets/react-icon.svg"
                         style="position: relative; left: -18%;">
                    <img class="logo fragment" data-fragment-index="0" data-src="assets/scala-js-logo.svg"
                         style="position: relative; left: 2%;">
                    <img class="logo fragment" data-fragment-index="0" data-src="assets/slinky-logo.svg"
                         style="position: relative; top: 5%; left: 19%;">
                </div>
            </section>

            <section>
                <h2>A Bit About Me</h2>
                <ul>
                    <li class="fragment">
                        Jason Pickens (
                        <img class="inline" data-src="assets/github-mark.svg">
                        <a href="https://github.com/steinybot">@steinybot</a>
                        )
                    </li>
                    <li class="fragment">
                        <div>
                            Father of 4 (2 human)
                            <div>
                                <img class="fragment fade-out" data-src="assets/babies.jpg"
                                     style="height: 400px; position: absolute;">
                            </div>
                        </div>
                    </li>
                    <li class="fragment">Graduate at Orion Health in 2010</li>
                    <li class="fragment">First intro to FP and Scala in 2013</li>
                    <li class="fragment">Did a stint at Lightbend</li>
                    <li class="fragment">Went to dinner with the Scala team</li>
                    <li class="fragment">Now at Goodcover</li>
                    <li class="fragment">Writing Scala professionally for ~7 years</li>
                </ul>
            </section>
        </section>
        <section>
            <h2>Teaser</h2>
            <div class="code-overlay-container r-stack">
                <pre><code data-trim data-line-numbers=""><script type="text/template">
import { ReactElement } from "react";

function RedList(props: { children: ReactElement[] }) {
  return <ul style={{ color: "red" }}>{props.children}</ul>;
}

function QuantifiedListItem(props: { amount: number, children: string }) {
  return <li>{props.children} * {props.amount}</li>;
}

export default function App() {
  return (
    <RedList>
      <li>Apple</li>
      <li>Banana</li>
      <QuantifiedListItem amount={5}>Cherries</QuantifiedListItem>
    </RedList>
  );
}
                </script></code></pre>
                <div class="code-overlay fragment r-frame">
                    <ul style="color: red;">
                        <li>Apple</li>
                        <li>Banana</li>
                        <li>Cherries * 5</li>
                    </ul>
                </div>
            </div>
            <aside class="notes">
                <pre>
This is a little teaser of the React app we will
be fixing up today.

This is the TypeScript version.

It renders an unordered list with list items, one
of which has an amount.
                </pre>
            </aside>
        </section>
        <section>
            <section>
                <h2>React</h2>
                <h3>A JavaScript library for building user interfaces</h3>
                <ul>
                    <li class="fragment">The community has provided TypeScript and Flow definitions</li>
                    <li class="fragment">Often used with JSX</li>
                    <li class="fragment">Concepts: Elements, Components, Props, State, Rendering</li>
                    <li class="fragment">Function and Class Components</li>
                </ul>
            </section>
            <section>
                <h2>React</h2>
                <pre><code data-trim data-line-numbers="4,8,14-15|3,7,11,13,16-17|"><script type="text/template">
import { ReactElement } from "react";

function RedList(props: { children: ReactElement[] }) {
  return <ul style={{ color: "red" }}>{props.children}</ul>;
}

function QuantifiedListItem(props: { amount: number, children: string }) {
  return <li>{props.children} * {props.amount}</li>;
}

export default function App() {
  return (
    <RedList>
      <li>Apple</li>
      <li>Banana</li>
      <QuantifiedListItem amount={5}>Cherries</QuantifiedListItem>
    </RedList>
  );
}
                </script></code></pre>
                <aside class="notes">
                    <pre>
1) Elements
2) Component and Props
                    </pre>
                </aside>
            </section>
        </section>
        <section>
            <h2>Untyped Children</h2>
            <div class="code-overlay-container r-stack">
                <pre><code data-trim data-line-numbers="3,15"><script type="text/template">
import { ReactElement } from "react";

function RedList(props: { children: ReactElement[] }) {
  return <ul style={{ color: "red" }}>{props.children}</ul>;
}

function QuantifiedListItem(props: { amount: number, children: string }) {
  return <li>{props.children} * {props.amount}</li>;
}

export default function App() {
  return (
    <RedList>
      <li>Apple</li>
      <li>Banana</li>
      <QuantifiedListItem amount={5}>Cherries</QuantifiedListItem>
    </RedList>
  );
}
                </script></code></pre>
                <pre class="fragment"><code data-trim data-line-numbers="3,15"><script type="text/template">
import { ReactElement } from "react";

function RedList(props: { children: ReactElement[] }) {
  return <ul style={{ color: "red" }}>{props.children}</ul>;
}

function QuantifiedListItem(props: { amount: number, children: string }) {
  return <li>{props.children} * {props.amount}</li>;
}

export default function App() {
  return (
    <RedList>
      <li>Apple</li>
      <p>Banana</p>
      <QuantifiedListItem amount={5}>Cherries</QuantifiedListItem>
    </RedList>
  );
}
                </script></code></pre>
                <div class="code-overlay fragment r-frame">
                    <ul style="color: red;">
                        <li>Apple</li>
                        <p>Banana</p>
                        <li>Cherries * 5</li>
                    </ul>
                </div>
            </div>
<!--        <ul>https://flow.org/en/docs/react/children/#toc-only-allowing-a-specific-element-type-as-children</ul>-->
            <aside class="notes">
                <pre>
1) The type of children is ReactElement,
   i.e. untyped.
2) Pass in any HTML element
3) Get semantically invalid HTML
                </pre>
            </aside>
        </section>
        <section>
            <h2>Scala.js</h2>
            <h3>Scala for the web</h3>
            <ul>
                <li class="fragment">Now a built-in target for the Scala compiler</li>
                <li class="fragment">Outputs .sjsir and .class files</li>
                <li class="fragment">Scala.js linker produces .js files</li>
                <li class="fragment">Same semantics as JVM (mostly)</li>
                <li class="fragment">Very good JavaScript interoperability</li>
                <li class="fragment">Generate Scala.js facades from TypeScript (<a href="https://scalablytyped.org/docs/readme.html">ScalablyTyped</a>)</li>
            </ul>
            <aside class="notes">
                <pre>
1) Enough about Typescript let's move on to
   Scala.js

2)
3)
4)
5)

6) JVM semantics with JS interop?
- 2 different type hierarchies (Any and js.Any)
- 3 different implementations:
  - 1) Scala types - not visible to JS
  - 2) JS native types -
       JS types implemented in JS with Scala.js
       facade
  - 3) Scala.js non-native types -
       JS types implemented in Scala.js

7) ScalablyTyped
                </pre>
            </aside>
        </section>
        <section>
            <section>
                <h2>Slinky</h2>
                <pre><code class="language-scala" data-trim data-line-numbers="1|3|5-8|10-11|13|15|17|"><script type="text/template">
val tag: WithAttrs[li.tag.type] = li("Apple")

val renderedTag: ReactElement = tag

val component: FunctionalComponent[Props] =
  FunctionalComponent[Props] { props =>
    li(s"${props.children} * ${props.amount}")
  }

def fn(amount: Int)(children: String) =
  li(s"$children * $amount")

val componentWithProps: KeyAddingStage = component(Props(5, "Cherries"))

val componentWithKey: ReactElement = componentWithProps.withKey("cherries")

val renderedComponent: ReactElement = componentWithProps
                </script></code></pre>
                <aside class="notes">
                    <pre>
Slinky is a Scala.js library for writing React
apps.

The API tries to match as close as possible to the
JS API.
                    </pre>
                </aside>
            </section>
            <section>
                <h2>Slinky</h2>
                <pre><code class="language-scala" data-trim data-line-numbers="2,5,9,10|1,4,7,8,11|"><script type="text/template">
def RedList(children: ReactElement*) =
  ul(style := js.Dynamic.literal(color = "red"))(children: _*)

def QuantifiedListItem(amount: Int)(children: String) =
  li(s"$children * $amount")

def App =
  RedList(
    li("Apple"),
    li("Banana"),
    QuantifiedListItem(5)("Cherries")
  )
                </script></code></pre>
                <aside class="notes">
                    <pre>
1) Here I'm highlighting the HTML elements or
   "tags".
2) And these are the components and their props.
3) NOTE: It looks pretty close the TS + JSX
                    </pre>
                </aside>
            </section>
            <section>
                <h2>Slinky</h2>
                <pre style="font-size: 0.4em;"><code class="language-scala" data-trim data-line-numbers="2,3,5,10,11,13,18,21-24|"><script type="text/template">
@react
object RedList {
  case class Props(children: ReactElement*)
  val component = FunctionalComponent[Props] { props =>
    ul(style := js.Dynamic.literal(color = "red"))(props.children: _*)
  }
}

@react
object QuantifiedListItem {
  case class Props(amount: Int, children: String)
  val component = FunctionalComponent[Props] { props =>
    li(s"${props.children} * ${props.amount}")
  }
}

@react
object App {
  type Props = Unit
  val component = FunctionalComponent[Props] { _ =>
    RedList(
      li("Apple"),
      li("Banana"),
      QuantifiedListItem(5)("Cherries")
    )
  }
}
                </script></code></pre>
                <aside class="notes">
                    <pre>
The previous slide showed the components
implemented as just functions which have some
limitations.

React doesn't see these as component and so they
can't use hooks (we will see hooks a bit later).

Here they are FunctionalComponents with case
classes for props.

Case classes are essentially record types.

That @react annotation is a macro which reduces
some boilerplate.
                    </pre>
                </aside>
            </section>
        </section>
        <section>
            <h2>Typed Children</h2>
            <div class="r-stack">
                <pre><code class="language-scala" data-trim data-line-numbers="1,10"><script type="text/template">
def RedList(children: ReactElement*) =
  ul(style := js.Dynamic.literal(color = "red"))(children: _*)

def QuantifiedListItem(amount: Int)(children: String) =
  li(s"$children * $amount")

def App =
  RedList(
    li("Apple"),
    li("Banana"),
    QuantifiedListItem(5)("Cherries")
  )
                </script></code></pre>
                <pre class="fragment"><code class="language-scala" data-trim data-line-numbers="1,10"><script type="text/template">
def RedList(children: ReactElement*) =
  ul(style := js.Dynamic.literal(color = "red"))(children: _*)

def QuantifiedListItem(amount: Int)(children: String) =
  li(s"$children * $amount")

def App =
  RedList(
    li("Apple"),
    p("Banana"), // This compiles fine 😒
    QuantifiedListItem(5)("Cherries")
  )
                </script></code></pre>
                <pre class="fragment"><code class="language-scala" data-trim data-line-numbers="1,10"><script type="text/template">
def RedList(children: TypedReactElement[li.tag.type]*) =
  ul(style := js.Dynamic.literal(color = "red"))(children: _*)

def QuantifiedListItem(amount: Int)(children: String) =
  li(s"$children * $amount")

def App =
  RedList(
    li("Apple"),
    p("Banana"), // This fails to compile 🥳
    QuantifiedListItem(5)("Cherries")
  )
                </script></code></pre>
            </div>
            <aside class="notes">
                <pre>
1)
Back to the problem!

We have a RedList component which takes any
ReactElement.

2) If we pass in a paragraph then it compiles.

3)
What we really want is one that only takes list
items,

like with this hypothetical API where the children
are TypedReactElements of list item tags.

Let's see how we might make this TypedReactElement.
                </pre>
            </aside>
        </section>
        <section>
            <section>
                <h2>Value Class</h2>
                <div class="r-stack">
                    <pre><code class="language-scala" data-line-numbers="1">
<script type="text/template">class TypedReactElement[Result](val element: ReactElement) extends AnyVal












                    </script></code></pre>
                    <pre class="fragment"><code class="language-scala" data-line-numbers="3-5">
<script type="text/template">class TypedReactElement[Result](val element: ReactElement) extends AnyVal

object TypedReactElement {
  implicit def fromTag[Result](tag: WithAttrs[Result]): TypedReactElement[Result] =
    new TypedReactElement(tag)



}




                    </script></code></pre>
                    <pre class="fragment"><code class="language-scala" data-line-numbers="7-8">
<script type="text/template">class TypedReactElement[Result](val element: ReactElement) extends AnyVal

object TypedReactElement {
  implicit def fromTag[Result](tag: WithAttrs[Result]): TypedReactElement[Result] =
    new TypedReactElement(tag)

  implicit def toReactElement(result: TypedReactElement[_]): ReactElement =
    result.asInstanceOf[ReactElement]
}




                    </script></code></pre>
                    <pre class="fragment"><code class="language-scala" data-line-numbers="11-13|">
<script type="text/template">class TypedReactElement[Result](val element: ReactElement) extends AnyVal

object TypedReactElement {
  implicit def fromTag[Result](tag: WithAttrs[Result]): TypedReactElement[Result] =
    new TypedReactElement(tag)

  implicit def toReactElement(result: TypedReactElement[_]): ReactElement =
    result.asInstanceOf[ReactElement]
}

val tag: WithAttrs[li.tag.type] = li("Apple")

val renderedTypedTag: TypedReactElement[li.tag.type] = tag
                    </script></code></pre>
                    <pre class="fragment"><code class="language-scala" data-trim data-line-numbers="1,10"><script type="text/template">
def RedList(children: TypedReactElement[li.tag.type]*) =
  ul(style := js.Dynamic.literal(color = "red"))(children: _*)

def QuantifiedListItem(amount: Int)(children: String) =
  li(s"$children * $amount")

def App =
  RedList(
    li("Apple"),
    p("Banana"), // This fails to compile 🥳
    QuantifiedListItem(5)("Cherries")
  )
                    </script></code></pre>
                </div>
                <aside class="notes">
                    <pre>
1)
Let's try something simple, a value class.

A value class is a wrapper around an existing
value.

It extends AnyVal.

It is just like other value types such as Int,
Double, Boolean.

It might end up being boxed and unboxed.

NOTE: How this has the Result type parameter.

2)
We don't want to have to manually wrap
ReactElements so we create an implicit conversion
from a tag to a TypedReactElement.

The type of tag, WithAttrs already has the result
so we pass that along.

3) We also want to automatically unwrap it.

4)
Here it is in action.

NOTE: We are going from a WithAttrs to a
TypedReactElement automatically and the Result
type stays.

-------------

Now if we look back at our example we get what we
wanted.

There is no implicit conversion from
WithAttrs[paragraph] to
TypedReactElement[list item]
                    </pre>
                </aside>
            </section>
            <section>
                <h2>Unexpected Allocation</h2>
                <pre><code class="language-plaintext" data-trim data-line-numbers="7"><script type="text/template">
49: invokevirtual #217  // Method slinky/web/html/li$.apply:(Lscala/collection/immutable/Seq;)Lscala/scalajs/js/Array;
52: invokevirtual #220  // Method Demo$TypedReactElement$.apply:(Lscala/scalajs/js/Array;)Lslinky/core/facade/ReactElement;
55: invokespecial #244  // Method Demo$TypedReactElement."<init>":(Lslinky/core/facade/ReactElement;)V
58: aastore
59: dup
60: iconst_1
61: new           #10   // class Demo$TypedReactElement
                </script></code></pre>
                <aside class="notes">
                    <pre>
The downside is that if we look at the byte code
we see there is a new instance being created.
                    </pre>
                </aside>
            </section>
        </section>
        <section>
            <h2>What About WithAttrs?</h2>
            <pre><code class="language-scala" data-trim data-line-numbers="1,10"><script type="text/template">
def RedList(children: WithAttrs[li.tag.type]*) =
  ul(style := js.Dynamic.literal(color = "red"))(children: _*)

def QuantifiedListItem(amount: Int)(children: String) =
  li(s"$children * $amount")

def App =
  RedList(
    li("Apple"),
    p("Banana"), // This also fails to compile 🤔
    QuantifiedListItem(5)("Cherries")
  )
            </script></code></pre>
            <aside class="notes">
                <pre>
You might have picked up that if WithAttrs
already has the Result type then why not just
use that?

As you can see here this also fails to compile
which is what we want.
                </pre>
            </aside>
        </section>
        <section>
            <h2>Remember KeyAddingStage?</h2>
            <div class="r-stack">
                <pre><code class="language-scala" data-trim data-line-numbers="5-6,14-16"><script type="text/template">
def RedList(children: TypedReactElement[li.tag.type]*) =
  ul(style := js.Dynamic.literal(color = "red"))(children)


def QuantifiedListItem(amount: Int)(children: String) =
  li(s"$children * $amount")





def App =
  RedList(
    li("Apple", key := "apple"),
    li("Banana", key := "banana"),
    QuantifiedListItem(5)("Cherries") // Where does the key go?
  )
                </script></code></pre>
                <pre class="fragment"><code class="language-scala" data-trim data-line-numbers="4-10,16"><script type="text/template">
def RedList(children: TypedReactElement[li.tag.type]*) =
  ul(style := js.Dynamic.literal(color = "red"))(children)

@react
object QuantifiedListItem {
  case class Props(amount: Int, children: String)
  val component = FunctionalComponent[Props] { props =>
    li(s"${props.children} * ${props.amount}")
  }
}

def App =
  RedList(
    li("Apple", key := "apple"),
    li("Banana", key := "banana"),
    QuantifiedListItem(5)("Cherries").withKey("cherries")
  )
                </script></code></pre>
                <pre class="fragment"><code class="language-scala" data-trim data-line-numbers="1,16"><script type="text/template">
def RedList(children: TypedReactElement[li.tag.type]*) =
  ul(style := js.Dynamic.literal(color = "red"))(children)

@react
object QuantifiedListItem {
  case class Props(amount: Int, children: String)
  val component = FunctionalComponent[Props] { props =>
    li(s"${props.children} * ${props.amount}")
  }
}

def App =
  RedList(
    li("Apple", key := "apple"),
    li("Banana", key := "banana"),
    QuantifiedListItem(5)("Cherries").withKey("cherries") // The type was lost 🤦
  )
                </script></code></pre>
            </div>
            <aside class="notes">
                <pre>
1)
Here I've updated the example to add keys to each
of the list items.

The QuantifiedListItem is just a function
which is going to return a WithAttrs.

WithAttrs already has all its attributes and so
where does the key go?

2)
We can try and make QuatifiedListItem a
FunctionalComponent.

Remember what we get from applying props to a
FunctionalComponent?

It is a KeyAddingStage. That has a withKey method.

3)
But that ain't going to work.

KeyAddingStage doesn't know about our Result type.

withKey returns an untyped ReactElement not our
TypedReactElement.
                </pre>
            </aside>
        </section>
        <section>
            <h2>TypedKeyAddingStage?</h2>
            <div class="r-stack">
                <pre><code class="language-scala" data-trim data-line-numbers=""><script type="text/template">
class TypedKeyAddingStage[Result](val stage: KeyAddingStage) extends AnyVal

                </script></code></pre>
                <pre class="fragment"><code class="language-scala" data-trim data-line-numbers=""><script type="text/template">
class TypedKeyAddingStage[Result](val stage: KeyAddingStage) extends AnyVal
// value class may not wrap another user-defined value class 😠
                </script></code></pre>
            </div>
            <aside class="notes">
                <pre>
1)
So we need the KeyAddingStage to retain the
Result type too.

How about creating a TypedKeyAddingStage?

2)
If we try the same thing with a value class then
we get this compilation error.

Ok that isn't going to work. Now what?
                </pre>
            </aside>
        </section>
        <section>
            <h2>Type Alias</h2>
            <div class="r-stack">
                <pre><code class="language-scala" data-line-numbers="1-3">
<script type="text/template">trait Tag

type TypedKeyAddingStage[Result] = KeyAddingStage with Tag














                </script></code></pre>
                <pre class="fragment"><code class="language-scala" data-line-numbers="5-8">
<script type="text/template">trait Tag

type TypedKeyAddingStage[Result] = KeyAddingStage with Tag

object TypedKeyAddingStage {
  def unsafe[Result](stage: KeyAddingStage) =
    stage.asInstanceOf[TypedKeyAddingStage[Result]]
}









                </script></code></pre>
                <pre class="fragment"><code class="language-scala" data-line-numbers="10-13">
<script type="text/template">trait Tag

type TypedKeyAddingStage[Result] = KeyAddingStage with Tag

object TypedKeyAddingStage {
  def unsafe[Result](stage: KeyAddingStage) =
    stage.asInstanceOf[TypedKeyAddingStage[Result]]
}

val cherries: KeyAddingStage = QuantifiedListItem(5)("Cherries")

val typedCherries: TypedKeyAddingStage[li.tag.type] =
  TypedKeyAddingStage.unsafe(cherries)




                </script></code></pre>
                <pre class="fragment"><code class="language-scala" data-line-numbers="15-18|">
<script type="text/template">trait Tag

type TypedKeyAddingStage[Result] = KeyAddingStage with Tag

object TypedKeyAddingStage {
  def unsafe[Result](stage: KeyAddingStage) =
    stage.asInstanceOf[TypedKeyAddingStage[Result]]
}

val cherries: KeyAddingStage = QuantifiedListItem(5)("Cherries")

val typedCherries: TypedKeyAddingStage[li.tag.type] =
  TypedKeyAddingStage.unsafe(cherries)

val fruit: Seq[TypedKeyAddingStage[li.tag.type]] = Seq(typedCherries)

val firstFruit: TypedKeyAddingStage[li.tag.type] = fruit.head
                </script></code></pre>
            </div>
            <pre class="fragment"><code class="language-plaintext" data-trim style="color: #d3423e;"><script type="text/template">
org.scalajs.linker.runtime.UndefinedBehaviorError:
java.lang.ClassCastException: object cannot be cast to slinky.core.KeyAddingStage
            </script></code></pre>
            <aside class="notes">
                <pre>
1)
We can try something else.

Scala has a simple feature called a type alias.

We can take whatever types we like (real or not)
and give them a new name.

In this case we take the untyped KeyAddingStage
and create an intersection with a new trait
called Tag.

2)
Next we create a function call unsafe which can
take an untyped KeyAddingStage and tag it with
the Result type.

This is named unsafe because there is nothing
restricting what Result can be.

3) So far so good.

4)

5) Now we run it...

6)
And get a runtime exception.

So the cast really is unsafe.
                </pre>
            </aside>
        </section>
        <section>
            <section>
                <h2>Structural Refinement</h2>
                <div class="r-stack">
                    <pre><code class="language-scala" data-line-numbers="1-3,7">
<script type="text/template">



trait Tag

type TypedKeyAddingStage[Result] = KeyAddingStage with Tag

object TypedKeyAddingStage {
  def unsafe[Result](stage: KeyAddingStage) =
    stage.asInstanceOf[TypedKeyAddingStage[Result]]
}

val cherries      = QuantifiedListItem(5)("Cherries")
val typedCherries = TypedKeyAddingStage.unsafe(cherries)
val fruit         = Seq(typedCherries)
val firstFruit    = fruit.head
                    </script></code></pre>
                    <pre class="fragment"><code class="language-scala" data-line-numbers="1-3,7|">
<script type="text/template">type Base = {
  type __TypedKeyAddingStage
}

trait Tag

type TypedKeyAddingStage[Result] = Base with KeyAddingStage with Tag

object TypedKeyAddingStage {
  def unsafe[Result](stage: KeyAddingStage) =
    stage.asInstanceOf[TypedKeyAddingStage[Result]]
}

val cherries      = QuantifiedListItem(5)("Cherries")
val typedCherries = TypedKeyAddingStage.unsafe(cherries)
val fruit         = Seq(typedCherries)
val firstFruit    = fruit.head
                    </script></code></pre>
                </div>
                <aside class="notes">
                    <pre>
1)
Now for the real trick.

We take the previous type alias...

2)
And add this funny looking thing called Base.

Base is a type alias but the right hand side has
this weird block looking thing.

This is called a Structural Refinement.

In this case it is refining the Any type (no
identifier before the opening bracket) and it has
another nested type alias with some arbitrary name.

3) Now this runs without blowing up at runtime.
                    </pre>
                </aside>
            </section>
            <section>
                <h2>Avoiding Allocation</h2>
                <pre><code class="language-diff" data-trim><script type="text/template">
 14: invokevirtual #54        // Method bll/DemoSpec$TypedKeyAddingStage$.unsafe:
-                             //   (Lscala/scalajs/js/Array;)Lscala/scalajs/js/Array;
+                             //   (Lscala/scalajs/js/Array;)Ljava/lang/Object;
 ...
 31: invokeinterface #71,  1  // InterfaceMethod scala/collection/immutable/Seq.head:
                              //   ()Ljava/lang/Object;
-36: checkcast     #73        // class slinky/core/KeyAddingStage
-39: invokevirtual #77        // Method slinky/core/KeyAddingStage.slinky$core$KeyAddingStage$$args:
-                             //   ()Lscala/scalajs/js/Array;
                </script></code></pre>
                <aside class="notes">
                    <pre>
What is really going on?

Here I'm showing a diff of the byte code before
and after adding the refinement type.

We can see that the result of the unsafe method is
a java/lang/Object not a scala/scalajs/js/Array.

It was a js.Array because that is the type of an
unboxed KeyAddingStage.

Now the compiler has given up trying to check
that our cast was safe. Yus!
                    </pre>
                </aside>
            </section>
        </section>
        <section>
            <h2>Extension Methods</h2>
            <div class="r-stack">
                <pre><code class="language-scala" data-trim data-line-numbers="16"><script type="text/template">
def RedList(children: TypedReactElement[li.tag.type]*) =
  ul(style := js.Dynamic.literal(color = "red"))(children)

@react
object QuantifiedListItem {
  case class Props(amount: Int, children: String)
  val component = FunctionalComponent[Props] { props =>
    li(s"${props.children} * ${props.amount}")
  }
}

def App =
  RedList(
    li("Apple", key := "apple"),
    li("Banana", key := "banana"),
    QuantifiedListItem(5)("Cherries").withKey("cherries") // The type was lost 🤦
  )
                </script></code></pre>
                <pre class="fragment"><code class="language-scala" data-trim data-line-numbers=""><script type="text/template">
type Base = {
  type __TypedKeyAddingStage
}

trait Tag








type TypedKeyAddingStage[Result] = Base with KeyAddingStage with Tag

object TypedKeyAddingStage {
  def unsafe[Result](stage: KeyAddingStage) =
    stage.asInstanceOf[TypedKeyAddingStage[Result]]
}
                </script></code></pre>
                <pre class="fragment"><code class="language-scala" data-trim data-line-numbers="7-12|"><script type="text/template">
type Base = {
  type __TypedKeyAddingStage
}

trait Tag

object Tag {
  implicit class Ops[Result](stage: TypedKeyAddingStage[Result]) {
    @inline def withKeyTyped(key: String): TypedReactElement[Result] =
      new TypedReactElement[Result](stage.asInstanceOf[KeyAddingStage].withKey(key))
  }
}

type TypedKeyAddingStage[Result] = Base with KeyAddingStage with Tag

object TypedKeyAddingStage {
  def unsafe[Result](stage: KeyAddingStage) =
    stage.asInstanceOf[TypedKeyAddingStage[Result]]
}
                </script></code></pre>
                <pre class="fragment"><code class="language-scala" data-trim data-line-numbers="16"><script type="text/template">
def RedList(children: TypedReactElement[li.tag.type]*) =
  ul(style := js.Dynamic.literal(color = "red"))(children)

@react
object QuantifiedListItem {
  case class Props(amount: Int, children: String)
  val component = FunctionalComponent[Props] { props =>
    li(s"${props.children} * ${props.amount}")
  }
}

def App =
  RedList(
    li("Apple", key := "apple"),
    li("Banana", key := "banana"),
    QuantifiedListItem(5)("Cherries").withKey("cherries") // The type was lost 🤦
  )
                </script></code></pre>
                <pre class="fragment"><code class="language-scala" data-trim data-line-numbers="16-17|"><script type="text/template">
def RedList(children: TypedReactElement[li.tag.type]*) =
  ul(style := js.Dynamic.literal(color = "red"))(children)

@react
object QuantifiedListItem {
  case class Props(amount: Int, children: String)
  val component = FunctionalComponent[Props] { props =>
    li(s"${props.children} * ${props.amount}")
  }
}

def App =
  RedList(
    li("Apple", key := "apple"),
    li("Banana", key := "banana"),
    TypedKeyAddingStage.unsafe(QuantifiedListItem(5)("Cherries"))
      .withKeyTyped("cherries")
  )
                </script></code></pre>
            </div>
            <aside class="notes">
                <pre>
1)
Now if we remind ourselves of the example, we have
the TypedKeyAddingStage but withKey is still going
to return an untyped ReactElement.

2)

3)
We need to add a new method to our
TypedKeyAddingStage.

It can't go on Tag because remember at runtime it
is being treated as just an Object and the real
type is actually a js.Array.

We can use an extension method on our Tag type.

I couldn't find a way to have it override the
existing withKey method so it's named withKeyTyped.

Normally extension methods go on a value class but
we already tried that so we use the inline hint.

4)
5)

6)
Now we are getting close but we still have this
manual call to unsafe.
                </pre>
            </aside>
        </section>
        <section>
            <h2>TypedFunctionalComponent</h2>
            <div class="r-stack">
                <pre><code class="language-scala" data-line-numbers="1-6">
<script type="text/template">class FunctionalComponent[Props](val component: js.Function) extends AnyVal with
  FunctionalComponentCore[
    Props,
    KeyAddingStage,
    FunctionalComponent[Props]
  ]







                </script></code></pre>
                <pre class="fragment"><code class="language-scala" data-line-numbers="1,8|4,11|">
<script type="text/template">class FunctionalComponent[Props](val component: js.Function) extends AnyVal with
  FunctionalComponentCore[
    Props,
    KeyAddingStage,
    FunctionalComponent[Props]
  ]

type TypedFunctionalComponent[Props, Result] =
  FunctionalComponentCore[
    Props,
    TypedKeyAddingStage[Result],
    FunctionalComponent[Props]
  ]
                </script></code></pre>
                <pre class="fragment"><code class="language-scala" data-line-numbers="1-5">
<script type="text/template">object FunctionalComponent {
  def apply[Props](fn: Props => ReactElement):
    FunctionalComponent[Props] =
      new FunctionalComponent[Props](???)
}







                </script></code></pre>
                <pre class="fragment"><code class="language-scala" data-trim data-line-numbers="1,7|2,8|3,9|2,10-11|"><script type="text/template">
object FunctionalComponent {
  def apply[Props](fn: Props => ReactElement):
    FunctionalComponent[Props] =
      new FunctionalComponent[Props](???)
}

object TypedFunctionalComponent {
  def apply[Props, Result](fn: Props => TypedReactElement[Result]):
    TypedFunctionalComponent[Props, Result] =
      FunctionalComponent(fn.andThen(_.element))
        .asInstanceOf[TypedFunctionalComponent[Props, Result]]
}
                </script></code></pre>
                <pre class="fragment"><code class="language-scala" data-trim data-line-numbers="7|16|"><script type="text/template">
def RedList(children: TypedReactElement[li.tag.type]*) =
  ul(style := js.Dynamic.literal(color = "red"))(children)

@react
object QuantifiedListItem {
  case class Props(amount: Int, children: String)
  val component = TypedFunctionalComponent[Props, li.tag.type] { props =>
    li(s"${props.children} * ${props.amount}")
  }
}

def App =
  RedList(
    li("Apple", key := "apple"),
    li("Banana", key := "banana"),
    QuantifiedListItem(5)("Cherries").withKeyTyped("cherries")
  )
                </script></code></pre>
            </div>
            <aside class="notes">
                <pre>
1)
Here is the definition for Slinky's
FunctionalComponent.

It's not exact but close enough.

2)
We want to create an alias that has both a Props
and a Result type.

The Props are handled the same.

3)
The only other difference is that we say that the
result of our TypedFunctionalComponent is a
TypedKeyAddingStage[Result]

4)

5)
Here is the apply method for Slinky's
FunctionalComponent.

6)
We create the same thing but replace all the
untyped bits with our typed ones.

7)
Result of the render function must be a
TypedReactElement.

8)
Specify the Result type of the
TypedFunctionalComponent.

9)
Call the untyped FunctionalComponent apply method
and cast the result.

10)

11)
Make our QuantifiedListItem a
TypedFunctionalComponent that returns a li.tag.

12) And finally we can drop that call to unsafe.
13) Now we have got a fully typed API.
                </pre>
            </aside>
        </section>
        <section>
            <section>
                <h2>Refined Types</h2>
                <div class="r-stack">
                    <pre><code class="language-scala" data-line-numbers="18">
<script type="text/template">




@react
object QuantifiedListItem {
  case class Props(amount: Int, children: String)
  val component = TypedFunctionalComponent[Props, li.tag.type] { props =>
    li(s"${props.children} * ${props.amount}")
  }
}

def App =
  RedList(
    li("Apple"),
    li("Banana"),
    QuantifiedListItem(-2)(" ") // We can do better 🧐
  )
                    </script></code></pre>
                    <pre class="fragment"><code class="language-scala" data-trim data-line-numbers="1-4,8,18"><script type="text/template">
object ItemTypes {
  type ItemAmount = PosInt
  type ItemName = String Refined (Trimmed And NonEmpty)
}

@react
object QuantifiedListItem {
  case class Props(amount: ItemAmount, children: ItemName)
  val component = TypedFunctionalComponent[Props, li.tag.type] { props =>
    li(s"${props.children} * ${props.amount}")
  }
}

def App =
  RedList(
    li("Apple"),
    li("Banana"),
    QuantifiedListItem(-2)(" ") // Fails to compile 💪
  )
                    </script></code></pre>
                    <pre class="fragment"><code class="language-scala" data-trim data-line-numbers="18|"><script type="text/template">
object ItemTypes {
  type ItemAmount = PosInt
  type ItemName = String Refined (Trimmed And NonEmpty)
}

@react
object QuantifiedListItem {
  case class Props(amount: ItemAmount, children: ItemName)
  val component = TypedFunctionalComponent[Props, li.tag.type] { props =>
    li(s"${props.children} * ${props.amount}")
  }
}

def App =
  RedList(
    li("Apple"),
    li("Banana"),
    QuantifiedListItem(5)("Cherries") // Compiles 🪄
  )
                    </script></code></pre>
                </div>
                <aside class="notes">
                    <pre>
1)
Something that sucks with the types of our props
is that they are not very precise.

2)
We can use Refined types from the Refined Scala
library to tag types with predicates such as an
Int that must be positive and a String that is
trimmed and non-empty.

Now these nonsense values will not compile.

3) Valid values will compile.
                    </pre>
                </aside>
            </section>
            <section>
                <h2>Inside Refined</h2>
                <pre><code class="language-scala" data-trim data-line-numbers="1|3-6|8-11|"><script type="text/template">
class Refined[T, P](val value: T) extends AnyVal

implicit def autoRefineV[T, P](t: T)(implicit
    rt: RefType[Refined],
    v: Validate[T, P]
): Refined[T, P] = macro RefineMacro.impl[Refined, T, P]

object Trimmed {
  implicit def trimmedValidate: Validate.Plain[String, Trimmed] =
    Validate.fromPredicate(s => s.trim == s, t => s"$t is trimmed", Trimmed())
}
                </script></code></pre>
                <aside class="notes">
                    <pre>
1)
For the curious among you, you can see that
Refined is a value class.

2)
It does some crazy macro shenanigans to validate
the value at compile time.

3)
Validations are just predicate functions, a
description, and a value of the tag.
                    </pre>
                </aside>
            </section>
        </section>
        <section>
            <h2>Unsafe Hooks</h2>
            <pre><code class="language-scala" data-trim data-line-numbers="|2|3|5,9|6|7|8|11|"><script type="text/template">
val component = FunctionalComponent[Unit] { _ =>
  val (messages, setMessages) = useState(Vector.empty[String])
  val (params, setParams) = useState(Params("", 10))

  useEffect(() => {
    setMessages(_ :+ s"Loading data with params: $params")
    val handle = setTimeout(1.seconds)(setMessages(_ :+ "Data loaded."))
    () => clearTimeout(handle)
  })

  textarea(readOnly := true, value := messages.mkString("\n"))
}
            </script></code></pre>
            <pre class="fragment"><code class="language-plaintext" data-trim style="color: #DCDCAA;"><script type="text/template">
//Warning: Maximum update depth exceeded.
//  This can happen when a component calls setState inside useEffect,
//  but useEffect either doesn't have a dependency array,
//  or one of the dependencies changes on every render.
            </script></code></pre>
            <aside class="notes">
                    <pre>
1) One last example.
   Here we have a FunctionalComponent that uses
   hooks to access its state and run effects.

2) It has state for some messages.

3) State for some query parameters.

4) It uses an effect hook with a callback.

5) The callback appends a loading message.

6) Sends a fake request to load data and add a
   loaded message when it is done.

7) It has some cleanup to remove the timeout if
   the component is unmounted.

8) Lastly it renders the messages in a textarea.

9) If we run this...

10) We get an infinite render loop.
                    </pre>
            </aside>
        </section>
        <section>
            <h2>Safer Hooks</h2>
            <div class="r-stack">
                 <pre><code class="language-scala" data-trim data-line-numbers="6"><script type="text/template">
val component = FunctionalComponent[Unit] { _ =>
  val (messages, setMessages) = useState(Vector.empty[String])
  val (params, setParams) = useState(Params("", 10))

  useEffect(() => {
    setMessages(_ :+ s"Loading data with params: $params")
    val handle = setTimeout(1.seconds)(setMessages(_ :+ "Data loaded."))
    () => clearTimeout(handle)
  })

  textarea(readOnly := true, value := messages.mkString("\n"))
}
                </script></code></pre>
                <pre class="fragment"><code class="language-scala" data-trim data-line-numbers="9|"><script type="text/template">
val component = FunctionalComponent[Unit] { _ =>
  val (messages, setMessages) = useState(Vector.empty[String])
  val (params, setParams) = useState(Params("", 10))

  useEffect(() => {
    setMessages(_ :+ s"Loading data with params: $params")
    val handle = setTimeout(1.seconds)(setMessages(_ :+ "Data loaded."))
    () => clearTimeout(handle)
  }, Seq(params))

  textarea(readOnly := true, value := messages.mkString("\n"))
}
                </script></code></pre>
            </div>
            <div class="fragment">
                <textarea readonly style="margin-top: 25px; width: 600px; font-size: 0.5em">Loading data with params: Params(,10)
Data loaded.</textarea>
            </div>
            <aside class="notes">
                    <pre>
1)
What you ought to do is not call setState from
within an effect but if you do...

2)
Ensure to provide some dependencies.

React will only run the effect if the dependencies
change.

3) This time...

4) It renders the messages as expected.
                    </pre>
            </aside>
        </section>
        <section>
            <h2>Safe...err Hooks</h2>
            <div class="r-stack">
                <div style="width: 100%;">
                    <div class="r-stack">
                        <pre><code class="language-scala" data-trim data-line-numbers=""><script type="text/template">
val component = FunctionalComponent[Unit] { _ =>
  val (messages, setMessages) = useState(Vector.empty[String])
  val (params, setParams) = useState(Params("", 10))





  useEffect(() => {
    setMessages(_ :+ s"Loading data with params: $params")
    val handle = setTimeout(1.seconds)(setMessages(_ :+ "Data loaded."))
    () => clearTimeout(handle)
  }, Seq(params))

  textarea(readOnly := true, value := messages.mkString("\n"))
}
                        </script></code></pre>
                        <pre class="fragment"><code class="language-scala" data-trim data-line-numbers="5-7,13|"><script type="text/template">
val component = FunctionalComponent[Unit] { _ =>
  val (messages, setMessages) = useState(Vector.empty[String])
  val (params, setParams) = useState(Params("", 10))

  val paramsWithDefaults = params.copy(
    text = if (params.text.nonEmpty) params.text else "foo"
  )

  useEffect(() => {
    setMessages(_ :+ s"Loading data with params: $paramsWithDefaults")
    val handle = setTimeout(1.seconds)(setMessages(_ :+ "Data loaded."))
    () => clearTimeout(handle)
  }, Seq(paramsWithDefaults))

  textarea(readOnly := true, value := messages.mkString("\n"))
}
                        </script></code></pre>
                    </div>
                    <pre class="fragment fade-in-then-out fade-to-nothing"><code class="language-plaintext" data-trim style="color: #DCDCAA;"><script type="text/template">
//Warning: Maximum update depth exceeded...
                    </script></code></pre>
                </div>
                <pre class="fragment"><code class="language-scala" data-trim data-line-numbers="5-7|"><script type="text/template">
val component = FunctionalComponent[Unit] { _ =>
  val (messages, setMessages) = useState(Vector.empty[String])
  val (params, setParams) = useState(Params("", 10))

  val paramsWithDefaults = useMemo(() => params.copy(
    text = if (params.text.nonEmpty) params.text else "foo"
  ), Seq(params))

  useEffect(() => {
    setMessages(_ :+ s"Loading data with params: $paramsWithDefaults")
    val handle = setTimeout(1.seconds)(setMessages(_ :+ "Data loaded."))
    () => clearTimeout(handle)
  }, Seq(paramsWithDefaults))

  textarea(readOnly := true, value := messages.mkString("\n"))
}
                </script></code></pre>
            </div>
            <aside class="notes">
                <pre>
1) What if we want to modify the params in the
   render function?

2) We could set the text to foo if it is empty.

3) Now...

4)
Infinite render again... Huh!?

React uses Object.is to compare the dependencies.

copy creates a new instance so Object.is will
return false.

5) The solution is to memoise the result.

6) Now it is fine but what a foot gun!
                </pre>
            </aside>
        </section>
        <section>
            <h2>Stable Tag</h2>
             <pre><code class="language-scala" data-trim data-line-numbers="1|5-7|9|11|13-14|"><script type="text/template">
type Stable[A] = Stable.Type[A]

object Stable {

  type Base = {
    type __Stable
  }

  sealed trait Tag extends Any

  type Type[A] <: Base with A with Tag

  def byReference[A](a: A): Stable[A] =
    a.asInstanceOf[Stable[A]]
}
            </script></code></pre>
            <aside class="notes">
                <pre>
Type-tagging to the rescue!

Here is our good old newtype boilerplate again
but for a type called Stable.

Something is considered stable if it is safe to
use with Object.is and as a dependency to a hook.

BTW: There is a library that has a macro which
expands to this but it has some subtle differences.
                </pre>
            </aside>
        </section>
        <section>
            <h2>Safety Hooks</h2>
            <pre><code class="language-scala" data-trim data-line-numbers="1-3|5-7|9-12|14-18|"><script type="text/template">
def useEffect(thunk: () => Unit,
              dependencies: Iterable[Stable[_]]): Unit =
  Hooks.useEffect(thunk, dependencies)

def useEffectCancellable(thunk: () => () => Unit,
                         dependencies: Iterable[Stable[_]]): Unit =
  Hooks.useEffect(thunk, dependencies)

def useState[A](initial: A): (Stable[A], SetStateHookCallback[A]) = {
  val (state, setState) = Hooks.useState(initial)
  (Stable.byReference(state), setState)
}

def useMemo[A](memoValue: () => A,
               dependencies: Iterable[Stable[_]]): Stable[A] = {
  val value = Hooks.useMemo[A](memoValue, dependencies)
  Stable.byReference(value)
}
            </script></code></pre>
            <aside class="notes">
                <pre>
1)
Now we replace all the hooks with safe versions.

This is the same useEffect hooks we saw before but
it requires Stable dependencies.

2) The one we want returns a cleanup callback.

3)
useState should also return a stable value.

The real implementation of this is far more
complicated but this shows the general idea.

4) And lastly, useMemo is the other way to obtain
a stable value.
                </pre>
            </aside>
        </section>
        <section>
            <h2>Safest Hooks</h2>
            <div class="r-stack">
                 <pre><code class="language-scala" data-trim data-line-numbers="5-7,13"><script type="text/template">
val component = FunctionalComponent[Unit] { _ =>
  val (messages, setMessages) = useState(Vector.empty[String])
  val (params, setParams) = useState(Params("", 10))

  val paramsWithDefaults = params.copy(
    text = if (params.text.nonEmpty) params.text else "foo"
  )

  useEffect(() => {
    setMessages(_ :+ s"Loading data with params: $paramsWithDefaults")
    val handle = setTimeout(1.seconds)(setMessages(_ :+ "Data loaded."))
    () => clearTimeout(handle)
  }, Seq(paramsWithDefaults)) // Fails to compile 🤘

  textarea(readOnly := true, value := messages.mkString("\n"))
}
                </script></code></pre>
                <pre class="fragment"><code class="language-scala" data-trim data-line-numbers="5-7,13|"><script type="text/template">
val component = FunctionalComponent[Unit] { _ =>
  val (messages, setMessages) = useState(Vector.empty[String])
  val (params, setParams) = useState(Params("", 10))

  val paramsWithDefaults = useMemo(() => params.copy(
    text = if (params.text.nonEmpty) params.text else "foo"
  ), Seq(params))

  useEffect(() => {
    setMessages(_ :+ s"Loading data with params: $paramsWithDefaults")
    val handle = setTimeout(1.seconds)(setMessages(_ :+ "Data loaded."))
    () => clearTimeout(handle)
  }, Seq(paramsWithDefaults)) // Compiles 😏

  textarea(readOnly := true, value := messages.mkString("\n"))
}
                </script></code></pre>
            </div>
            <aside class="notes">
                <pre>
1)
If we use these new hooks, this example no longer
compiles since it is not stable.

Copying a stable value is not stable which is what
we want.

2) Memoising the copy and it compiles
                </pre>
            </aside>
        </section>
        <section>
            <section>
                <h2>Type-Tagging</h2>
                <ul>
                    <li>Tag a type with another type</li>
                    <li class="fragment">Use that other type to enforce rules at compile time</li>
                    <li class="fragment">Augment an existing API</li>
                    <li class="fragment">Make illegal states and values unrepresentable</li>
                    <li class="fragment">Enforce order of function calls</li>
                    <li class="fragment">Fewer bugs</li>
                    <li class="fragment">More maintainable code</li>
                </ul>
            </section>
            <section>
                <h2>Type-Tagging</h2>
                <ul>
                    <li>Approaches shown:
                        <ul>
                            <li>Value Class (Scala 2+)</li>
                            <li>Based on Newtype (<a href="https://github.com/estatico/scala-newtype">estatico/scala-newtype</a>)</li>
                        </ul>
                    </li>
                    <li>Other variations:
                        <ul>
                            <li>Shapeless' @@ (<a href="https://github.com/milessabin/shapeless">milessabin/shapeless</a>)</li>
                            <li>Scalaz's @@ (<a href="https://github.com/milessabin/shapeless">scalaz/scalaz</a>)</li>
                            <li>Opaque Types (Scala 3)</li>
                        </ul>
                    </li>
                </ul>
            </section>
        </section>
        <section>
            <h1>Thanks!</h1>
            <p>Slides and code: <a href="https://github.com/steinybot/big-little-types">steinybot/big-little-types</a></p>
            <p>Libraries coming soon...</p>
        </section>
    </div>
</div>

<script src="dist/reveal.js"></script>
<script src="plugin/notes/notes.js"></script>
<script src="plugin/markdown/markdown.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
        hash: true,

        // NOTE: Fix the hero height if changing this.
        width: 1440,
        // margin: 0.05,

        totalTime: 1800,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
    });
</script>
</body>
</html>
